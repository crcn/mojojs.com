{
  "name": "structr",
  "description": "Clean OO structure for Javascript.",
  "version": "0.1.3",
  "author": {
    "name": "Craig Condon"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/spiceapps/Structr.git"
  },
  "main": "./lib/index.js",
  "readme": "Structr -  Structure for Javascript            \n======================================== \n\nStructr is a framework with the following goals:\n                                               \n* Lightweight.\n* Provide as few new concepts as possible coming from OOP.\n* Easy to learn.\n* Help develop re-useable, clean, and consistent code.              \n* Reduce the amount of reduntant/boilerplate code.  \n\t\n\nSupports:        \n                                             \n* _super                                     \n* inheritance      \n* overloading methods\n* Implicit / Explicit getters & setters\n* Override, and Static       \n* metadata      \n* mixing modifiers. e.g: 'explicit bindable name': function(){}          \n\t\n\nInstallation\n------------\n\nNode.js: \n\n\tnpm install structr\n\t\t   \n\t\t\nUsing Structr\n-------------\n\n\n```javascript\n \nvar Recipe = Structr({  \n\t\n\t'__construct': function (name)\n\t{\n\t\tthis._name = name;\n\t},                \n\t\n\t'name': function ()\n\t{\n\t\treturn this._name;\n\t},\n\t\n\t'ingredients': function ()\n\t{\n\t\talert('This is going to be tasty...');\n\t}\n});                      \n\nvar tiramisuRecipe = new Recipe('Tiramisu');   \nconsole.log(tiramisuRecipe.name()); //tiramisu\n\n```\n\n\n### Class.extend\n\n\n```javascript\n\nvar TiramisuRecipe = Recipe.extend({\n\n\t'override __construct': function ()\n\t{\n\t\tthis._super('Tiramisu');\n\t},\n\t\n\t'override ingredients': function ()\n\t{\n\t\tthis._super();\n\t\t\n\t\talert('Mascarpone, Heavy Cream, Eggs, Espresso, Sugar, Cocoa, Baileys, and Lady Fingers.');\n\t}\n});\n\nvar PastaRecipe = Recipe.extend({\n\t\n\t'override __construct': function ()\n\t{\n\t\tthis._super('Pasta');\n\t},\n\t\n\t'override ingredients': function ()\n\t{\n\t\tthis._super();\n\t\t\n\t\talert('Eggs, Flour, Water, Salt');\n\t}\n});\n\nvar tiramisu = new TiramisuRecipe();\nvar pasta = new PastaRecipe();\n\ntiramisu.ingredients();\npasta.ingredients();\n\n```\n\n\n\nModifiers\n---------      \n                      \n### Overriding Methods\n\nMethods overridden have access to the _super property.\n\n```javascript\n\n'override __construct': function ()\n{\n\tthis._super();\n}\n\n```\n\n### Overwriting Methods\n   \nFaster if you don't plan on using _super.\n\n\n```javascript\n\n'__construct': function ()\n{\n\t//cannot access _super __construct\n}\n\n```\n\t\n\t\n### Overloading Methods (Experimental)\n\nOverloading methods allows you to write polymorphic functions which are mapped out depending on the number of parameters used. You must provide your own identifier (it could be anything) for each overloaded method, otherwise you'll simply be overwriting methods. \n\n\n```javascript\n\nvar Person = Structr({\n\n\t'sayHello': function (name, callback)\n\t{\n\t\tthis._name = name;\n\t\tthis.sayHello(callback);\n\t},\n\n\t'2 sayHello': function (callback)\n\t{\n\t\tcallback(this.sayHello());\n\t},\n\n\t'3 sayHello': function ()\n\t{\n\t\treturn 'Hello ' + this._name;\n\t}\n});\n\nvar SubPerson = Person.extend({\n\n\t'override sayHello': function (callback)\n\t{\n\t\tcallback(this.sayHello() + ' Do you like italian food?');\n\t},\n\n\t'override second sayHello': function ()\n\t{\n\t\treturn 'Hello ' + this._name + ', how are you doing today?';\n\t}\n});\n\n\nvar p = new SubPerson();\np.sayHello('Craig', function(message)\n{\n\talert(message); //Hello Craig. how are you doing today? Do you like italian food?\n});\n\n```\n\n### Static Keyword \n\nProperties, and methods set to the class versus objects instantiated.\n\n\n```javascript\n\nvar Singleton = Structr({\n\t\n\t'static getInstance': function ()\n\t{\n\t\treturn this._instance || (this._instance = new Singleton());\n\t}\n});\n\nvar test1 = Singleton.getInstance();\nvar test2 = Singleton.getInstance();\ntest2.name = 'Craig';\n\nconsole.log(test1.name); //Craig\n\n```\n\n### Getters & Setters   \n\nBoth Implicit / Explicit methods are supported, however implicit getters & setters aren't supported in all browsers. Use implicit get/set if you're doing any development under a specific platform such as Node.js, or Appcelerator Titanium.\n\n\n\n```javascript\n\nvar GSTestClass = Structr({\n\n\t'explicit explicitValue': {\n\t\tget: function ()\n\t\t{\n\t\t\treturn this._name;\n\t\t},\n\t\tset: function (value)\n\t\t{\n\t\t\tthis._name = value;\n\t\t}\n\t},\n\t\n\t'implicit implicitValue': {\n\t\tget: function ()\n\t\t{\n\t\t\treturn this._name;\n\t\t},\n\t\tset: function (value)\n\t\t{\n\t\t\tthis._name = value;\n\t\t}\n\t},\n\t\n\t'explicit explicitValue2':true\n});\n\n\nvar test = new GSTestClass();\ntest.explicitValue('Craig'); \nconsole.log(test.explicitValue());\n\ntest.implicitValue = 'Tim';\nconsole.log(test.implicitValue);//Tim\nconsole.log(test.explicitValue());//Tim\n\ntest.explicitValue2('hello world');\nconsole.log(test.explicitValue2());//hello world\n\t\n```\n\nMetadata \n--------\n\nCustom modifiers are considered metadata. Use them to identify how specific methods should be handled.\n\n\n```javascript\n\n\nvar MetadataTestClass = Structr({\n\t\n\t'myCustomMetadata test': function ()\n\t{\n\t\treturn 'Hello Test';\n\t}\n}));\n\n\nconsole.log(MetadataTestClass.prototype.test.myCustomMetadata); //true\n\n```\n\t\n\t\n###Bindable Metadata\n\nTo add. Makes a property bindable for change. Psuedocode:\n\n\n```javascript\n\nvar Person = Structr({\n\t\n\t'__construct': function(name)\n\t{\n\t\tthis.name(name);\n\t\t\n\t\tBindable.apply(this);\n\t},\n\t\n\t'bindable explicit name': 1\n});\n\n\nvar person1 = new Person('craig');\n\n//listen for any change to name\nperson1.name.subscribe(function(newName)\n{\n\talert('Name changed to '+newName);\n});\n\n//on change the subscribers will be triggered\nperson1.name('Craig');\n\n```\n\t\n###Setting Metadata\n\nTo add. Easy way to store settings on the user's computer. Psuedocode:\n\n\n```javascript\n\nvar User = Structr({\n\n\t'__construct': function ()\n\t{\n\t\tSettingManager.apply(this);\n\t},\n\t\n\t'login': function ()\n\t{\n\t\t\n\t\t//set the account info which will be saved as a cookie\n\t\tthis.accountInfo({ name: 'Craig', last: 'Condon', 'token': 'XXXXXXXXXX' })\n\t},\n\t\n\t'setting explicit accountInfo': 1\n});\n\n\nvar u = new User();\n\n//this gets passed once\nif(!u.accountInfo)\n{\n\tu.login();\n}\nelse\n{\n\t//pulled from local computer\n\talert(u.accountInfo.name);\n}\n\n```\n\t\n\t\nTips:\n----\n\n* Use underscores before any private method / property. \n\nE.g: \n\n\n```javascript\n\nvar SomeClass = Structr({\n\t\n\t'__construct': function ()\n\t{\n\t\tthis._myPrivateVariable = 'some private value';\n\t},\n\t\n\t'_myPrivateMethod': function ()\n\t{\n\t\t//private stuff here\n\t}\n});\n\n```\n\t\n* Wrap methods / properties in single, or double quotes. \n* Avoid the over-use of override, or overloaded methods.\n* Only use Structr where you would create prototyped classes.\n\n\nTo Do:\n------\n\n- change _super(...) to _super({ method: [args]  }), or _super('method').call(...);\n\n\t\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/spiceapps/Structr/issues"
  },
  "homepage": "https://github.com/spiceapps/Structr",
  "_id": "structr@0.1.3",
  "_shasum": "f51ae6ee982470322e4e8e2e83904bd4f95366d2",
  "_from": "structr@0.1.x",
  "_resolved": "http://registry.npmjs.org/structr/-/structr-0.1.3.tgz",
  "scripts": {}
}
